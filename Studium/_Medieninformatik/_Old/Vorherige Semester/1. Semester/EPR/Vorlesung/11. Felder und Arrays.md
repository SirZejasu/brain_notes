#Vorlesung 
#EPR 
#Medieninformatik 

---
[[13_Felder.pdf]]

# SC Beispiele
## Erweiterte For-Schleife
```java

/**
 * Diese Klasse gibt Code-Beispiele für erweiterte for-Schleifen über Felder.
 */
public class ErweiterteForSchleife {

  /**
   * Berechnet den Durchschnitt der übergebenen Werte.
   *
   * @param werte Werte, deren Durchschnitt berechnet wird.
   * @return Durchschnitt
   */
  private static double gibDurchschnitt(double[] werte) {

    double summe = 0;

    for (double wert : werte) {
      summe = summe + wert;
    }

    return summe / werte.length;
  }

  /**
   * Ruft Testmethode auf.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    System.out.println(gibDurchschnitt(new double[]{2.5, 1.5, -3.5, 0.5}));
  }
}

```

## Feldtest
```java

/**
 * Diese Klasse veranschaulicht die Verwendung von Feldern.
 */
public class FeldTest {

  /**
   * Größe des Felds.
   */
  private static final int FELDGROESSE = 5;

  /**
   * Abstand zur besseren Lesbarkeit von Ausgaben.
   */
  private static final String ABSTAND = " ";

  /**
   * Kleines Beispiel: Feld erzeugen, Komponenten initialisieren und ausgeben.
   */
  public static void testeFeld() {

    /*
     * Durch die Deklaration einer Feld-Variablen wird noch KEIN Feld ERZEUGT. Es wird nur
     * festgelegt, dass die Variable ein Feld enthalten kann.
     */
    int[] zahlenfolge;

    /*
     * Feld der festgelegten Größe erzeugen und der Variablen zuweisen.
     */
    zahlenfolge = new int[FELDGROESSE];

    /*
     * Feld-Komponenten mit Werten belegen
     */
    for (int i = 0; i < FELDGROESSE; i = i + 1) {
      zahlenfolge[i] = 2 * i;
    }

    /*
     * Feld-Komponenten in Reihenfolge absteigender Indizes ausgeben
     */
    for (int i = FELDGROESSE - 1; i >= 0; i = i - 1) {
      System.out.println(zahlenfolge[i]);
    }
  }

  /**
   * Berechnet den Mittelwert der Zahlen eines int-Felds.
   *
   * @param zahlenfolge Folge, deren Mittelwert berechnet wird
   * @return Mittelwert
   */
  public static double gibMittelwert(int[] zahlenfolge) {

    /*
     * Summe aller Feldwerte
     */
    int summe = 0;

    /*
     * Werte der Folge addieren (mit normaler for-Schleife). 0 ist kleinster Index; length gibt
     * Länge des Feldes an, entsprechend ist length - 1 der größte gültige Index.
     */
    for (int i = 0; i < zahlenfolge.length; i = i + 1) {
      summe = summe + zahlenfolge[i];
    }

    /*
     * Werte der Folge addieren (mit erweiterter for-Schleife).
     */
    summe = 0;
    for (int wert : zahlenfolge) {
      summe = summe + wert;
    }

    return (double) summe / zahlenfolge.length;
  }

  /**
   * Veranschaulicht die Übergabe eines Felds an eine Methode. Erhöht alle Komponenten des Feldes um
   * einen Faktor.
   *
   * @param folge  Folge, deren Komponenten erhöht werden
   * @param faktor Faktor für Multiplikation
   */
  public static void erhoeheUmFaktor(int[] folge, int faktor) {

    /*
     * Feldwerte in Schleife um Faktor erhöhen
     */
    for (int i = 0; i < folge.length; i = i + 1) {
      folge[i] = folge[i] * faktor;
    }

    /*
     * Ausgabe der Feld-Komponenten
     */
    for (int i = 0; i < folge.length; i = i + 1) {
      System.out.print(folge[i] + ABSTAND);
    }
    System.out.println();
  }

  /**
   * Gibt an, ob ein Feld einen bestimmten Wert enthält.
   *
   * @param folge Feld, in dem Wert gesucht wird
   * @param wert  Wert, der in Feld gesucht wird
   * @return {@code true} genau dann, wenn das Feld den Wert enthält
   */
  public static boolean enthaeltWert(int[] folge, int wert) {

    boolean enthaeltWert = false;
    for (int i = 0; i < folge.length && !enthaeltWert; i++) {
      enthaeltWert = folge[i] == wert;
    }
    return enthaeltWert;

    // oder so:
//    int i = 0;
//    while (i < folge.length && folge[i] != wert) {
//      i++;
//    }
//    return i < folge.length;
  }

  /**
   * Veranschaulicht, dass es sich bei Feldern um Objekte handelt.
   */
  public static void testeIdentitaet1() {

    int[] ersteFolge = new int[FELDGROESSE];

    /*
     * Belegung der Feld-Komponenten
     */
    for (int i = 0; i < ersteFolge.length; i = i + 1) {
      ersteFolge[i] = 2 * i;
    }

    int[] zweiteFolge = ersteFolge;  // KEINE KOPIE

    /*
     * Ausgabe der Feld-Komponenten der ersten Folge
     */
    for (int i = 0; i < ersteFolge.length; i = i + 1) {
      System.out.print(ersteFolge[i] + ABSTAND);
    }
    System.out.println();

    /*
     * Ausgabe der Feld-Komponenten der zweiten Folge
     */
    for (int i = 0; i < zweiteFolge.length; i = i + 1) {
      System.out.print(zweiteFolge[i] + ABSTAND);
    }
    System.out.println();

    /*
     * Den Wert einer Komponenten der zweiten Folge ändern
     */
    zweiteFolge[0] = -999;

    /*
     * Den Wert einer Komponente der ersten Folge ändern
     */
    ersteFolge[ersteFolge.length - 1] = 999;

    /*
     * Ausgabe der Feld-Komponenten der ersten Folge
     */
    for (int i = 0; i < ersteFolge.length; i = i + 1) {
      System.out.print(ersteFolge[i] + ABSTAND);
    }
    System.out.println();

    /*
     * Ausgabe der Feld-Komponenten der zweiten Folge
     */
    for (int i = 0; i < zweiteFolge.length; i = i + 1) {
      System.out.print(zweiteFolge[i] + ABSTAND);
    }

    /*
     * Übung: Schreiben Sie eine Methode mit einem int-Feld als formalem Parameter, die alle
     * Komponenten des übergebenen Felds auf dem Bildschirm ausgibt.
     */
  }

  /**
   * Ähnlich wie testeIdentitaet1, hier wird das Feld aber nicht explizit zugewiesen, sondern
   * implizit durch Parameterübergabe.
   */
  public static void testeIdentitaet2() {

    int[] zahlenfolge = new int[]{1, 2, 3, 4, 5};

    /*
     * Während der Ausführung der Methode erhoeheUmFaktor enthält deren Parametervariable feld
     * dasselbe Feld, das auch in der Variablen zahlenfolge enthalten ist. Die Änderungen der
     * Feldwerte sind nach Ausführung der Methode deshalb über die Variable zahlenfolge weiter
     * sichtbar.
     */
    erhoeheUmFaktor(zahlenfolge, 3);

    /*
     * Ausgabe der Feld-Komponenten
     */
    for (int i = 0; i < zahlenfolge.length; i = i + 1) {
      System.out.print(zahlenfolge[i] + ABSTAND);
    }
    System.out.println();
  }

  /**
   * Hat weniger mit Feldern, sondern mehr mit "allgemeinen" Objekten zu tun. Ein Feld, dessen
   * Komponenten Objekte sind, kann in verschiedenen Komponenten DASSELBE Objekt enthalten.
   */
  public static void testeIdentitaet3() {

    Rechteck[] rechtecke = new Rechteck[FELDGROESSE];

    /*
     * Alle Komponenten des Felds initialisieren.
     */
    rechtecke[0] = new Rechteck(1, 2, 3, 4);
    Rechteck r = new Rechteck(10, 11, 12, 13);
    rechtecke[1] = r;
    rechtecke[2] = r;  // enthält nun dasselbe Rechteck wie Komponente 1
    rechtecke[3] = rechtecke[0];  // enthält dasselbe Rechteck wie Komp. 0
    rechtecke[4] = new Rechteck(100, 200, 300, 400);

    /*
     * Rechtecke des Felds textuell auf Bildschirm darstellen.
     */
    for (int i = 0; i < rechtecke.length; i = i + 1) {
      System.out.println(i + ": " + rechtecke[i].gibAlsString());
    }

    /*
     * "Zwei" Rechtecke verschieben.
     */
    r.verschiebe(2, 4);
    rechtecke[3].verschiebe(100, 200);

    System.out.println();

    /*
     * Rechtecke des Felds textuell auf Bildschirm darstellen.
     */
    for (int i = 0; i < rechtecke.length; i = i + 1) {
      System.out.println(i + ": " + rechtecke[i].gibAlsString());
    }
  }

  /**
   * Erzeugt eine Kopie eines int-Felds.
   *
   * @param folge Folge, die kopiert wird
   * @return kopierte Folge
   */
  public static int[] kopiereIntFeld(int[] folge) {

    /*
     * Neues Feld in der Größe des übergebenen Felds erzeugen.
     */
    int[] kopie = new int[folge.length];

    /*
     * Inhalte des übergebenen Feldes den Komponenten des neuen Feldes zuweisen.
     */
    for (int i = 0; i < folge.length; i = i + 1) {
      kopie[i] = folge[i];
    }

    return kopie;
  }

  /**
   * Führt die Testmethoden aus und stellt Ergebnisse durch Bildschirmausgaben dar.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    testeFeld();

    /*
     * Initialisierung von Feldern
     */
    int[] folge = new int[4];
    folge[0] = 1;
    folge[1] = 2;
    folge[2] = 4;
    folge[3] = 8;
    System.out.println(gibMittelwert(folge));

    /*
     * oder so:
     */
    int[] folge2 = new int[]{1, 2, 4, 8};
    System.out.println(gibMittelwert(folge2));

    /*
     * oder so, weil new int[]{...} ein Ausdruck ist:
     */
    System.out.println(gibMittelwert(new int[]{1, 2, 4, 8}));

    testeIdentitaet1();

    testeIdentitaet2();


    /*
     * Felder als Ergebniswerte
     */
    int[] folge3 = kopiereIntFeld(new int[]{1, 2, 3, 4, 5, 6});
    for (int i = 0; i < folge3.length; i = i + 1) {
      System.out.print(folge3[i] + ABSTAND);
    }
    System.out.println();

    testeIdentitaet3();
  }
}

```

## IntArrayListe
```java

/**
 * Ein Objekt dieser Klasse repräsentiert eine potenziell unbeschränkte Liste ganzer
 * Zahlen. Der Zugriff auf die Elemente der Liste erfolgt per Index.
 */
public class IntArrayListe {

  /*
   * Die Elemente der Liste werden intern in einem "gewöhnlichen" Feld verwaltet. Ist die Kapazität
   * des Felds erreicht, wird ein neues größeres Feld erzeugt und die Elemente werden dorthin
   * umkopiert.
   */

  /**
   * Anfangsgröße des Felds.
   */
  private static final int INITIALE_GROESSE = 1;

  /**
   * Schrittweite zur Vergrößerung des Felds.
   */
  private static final int VERGROESSERUNGSSCHRITT = 2;

  /**
   * Feld zur Vewaltung der Elemente.
   */
  private int[] elemente;

  /**
   * Gibt an, wieviele Komponenten des Felds genutzt werden.
   */
  private int anzahl;

  /**
   * Erzeugt ein neues Objekt der Klasse. Das Feld hat die anfängliche Standardgröße.
   */
  public IntArrayListe() {

    elemente = new int[INITIALE_GROESSE];
    anzahl = 0;
  }

  /**
   * Erzeugt ein neues Objekt dieser Klasse. Das Feld hat die angegebene Größe.
   *
   * @param groesse anfängliche Größe des Felds
   */
  public IntArrayListe(int groesse) {

    elemente = new int[groesse];
    anzahl = 0;
  }

  /**
   * Vergrößert das Feld zur Verwaltung der Elemente.
   */
  private void vergroessereFeld() {

    System.out.println("Das Feld wird vergrößert.");

    /*
     * Größeres Feld erzeugen.
     */
    int[] kopierFeld = new int[elemente.length + VERGROESSERUNGSSCHRITT];

    /*
     * Elemente umkopieren.
     */
    for (int i = 0; i < elemente.length; i = i + 1) {
      kopierFeld[i] = elemente[i];
    }

    /*
     * Das neue Feld enthält nun die Elemente dieses Objekts.
     */
    elemente = kopierFeld;
  }

  /**
   * Fügt der Liste ein Element hinzu.
   *
   * @param zahl Element, das hinzugefügt wird
   */
  public void fuegeHinzu(int zahl) {

    System.out.println("fuegeHinzu wird aufgerufen.");

    if (anzahl == elemente.length) {

      /*
       * Feld vergrößern, da Kapazität erreicht ist.
       */
      this.vergroessereFeld();
    }

    elemente[anzahl] = zahl;
    anzahl = anzahl + 1;
  }

  /**
   * Liefert das Element der Liste an der angegebenen Position, falls diese Position gültig ist.
   * Sonst wird 0 zurückgegeben.
   *
   * @param index Position der Liste, deren Wert zurückgegeben wird
   * @return Wert an der angegebenen Position; ist die Position ungültig, wird 0 zurückgegeben
   */
  public int gib(int index) {

    /*
     * 0 wird zurückgegeben, wenn index ungültig ist.
     */
    return ((index >= 0) && (index < anzahl))
            ? elemente[index]
            : 0;
  }

  /**
   * Ändert den Wert dieser Liste an der angegebenen Position auf den übergebenen Wert. Ist die
   * Position ungültig, bleibt die Liste unverändert.
   *
   * @param index Position, an der der Wert der Liste geändert wird
   * @param wert  Wert für die angegebene Listenposition
   */
  public void setze(int index, int wert) {

    if ((index >= 0) && (index < anzahl)) {
      elemente[index] = wert;
    }
  }

  /**
   * Liefert die aktuelle Größe dieser Liste.
   *
   * @return Größe dieser Liste
   */
  public int gibGroesse() {

    return anzahl;
  }
}

```

## IntArrayListeTest
```java

/**
 * Veranschaulicht die Verwendung der Methoden der Klasse IntArrayListe.
 */
public class IntArrayListeTest {

  /**
   * Ruft Methoden auf und gibt Ergebnisse auf dem Bildschirm aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    IntArrayListe liste = new IntArrayListe(3);

    liste.fuegeHinzu(1);
    liste.fuegeHinzu(4);
    liste.fuegeHinzu(9);
    liste.fuegeHinzu(16);
    liste.fuegeHinzu(25);
    liste.fuegeHinzu(36);
    liste.fuegeHinzu(49);

    for (int i = 0; i < liste.gibGroesse(); i = i + 1) {
      System.out.println("Wert in Komponente " + i + ": "
              + liste.gib(i));
    }

    liste.setze(2, 99);
    for (int i = 0; i < liste.gibGroesse(); i = i + 1) {
      System.out.println("Wert in Komponente " + i + ": "
              + liste.gib(i));
    }
  }
}

```

## MehrDimensionalesFeldTest
```java
/**
 * Diese Klasse veranschaulicht die Verwendung mehrdimensionaler Felder.
 */
public class MehrdimensionalesFeldTest {

  /**
   * Gibt einen Text auf dem Bildschirm aus, der die Dimensionen eines zweidimensionalen Felds
   * beschreibt.
   *
   * @param matrix zweidimensionales Feld
   */
  private static void zeigeDimensionen(int[][] matrix) {

    System.out.println("Feld hat " + matrix.length + " Komponenten.");

    for (int i = 0; i < matrix.length; i = i + 1) {
      System.out.print("  Die " + i + "-te Komponente ist");
      System.out.println(" ein Feld mit "
              + matrix[i].length + " Komponenten.");
    }
  }

  /**
   * Gibt die Werte eines zweidimensionalen Felds ganzer Zahlen auf dem Bildschirm aus.
   *
   * @param matrix zweidimensionales Feld
   */
  private static void zeigeMatrix(int[][] matrix) {

    for (int i = 0; i < matrix.length; i = i + 1) {
      for (int j = 0; j < matrix[i].length; j = j + 1) {
        System.out.print(matrix[i][j] + " ");
      }
      System.out.println();
    }

    /*
     * Alternative Realisierung mit erweiterter for-Schleife
     */
    for (int[] z : matrix) {
      for (int e : z) {
        System.out.print(e + " ");
      }
      System.out.println();
    }
  }

  /**
   * Liefert eine Multiplikationstabelle für die natürlichen Zahlen aus den Intervallen, die durch
   * die übergebenen Parameter festgelegt werden.
   *
   * @param n bestimmt Intervall {1, ..., n} für ersten Operanden
   * @param m bestimmt Intervall {1, ..., m} für zweiten Operanden
   * @return Feld mit Multiplikationstabelle; Feld besitzt n Komponenten, die jeweils Felder mit m
   *         int-Komponenten sind
   */
  private static int[][] erzeugeProduktMatrix(int n, int m) {

    /*
     * Feld für Verknüpfungstabelle erzeugen.
     */
    int[][] tabelle = new int[n][m];

    /*
     * Zahlen multiplizieren und in entsprechenden Feldern der Verknüpfungstabelle ablegen.
     */
    for (int i = 0; i < n; i = i + 1) {
      for (int j = 0; j < m; j = j + 1) {
        tabelle[i][j] = (i + 1) * (j + 1);
      }
    }

    return tabelle;
  }

  /**
   * Liefert ein Multiplikationsdreieck für die natürlichen Zahlen aus dem Intervall, das durch den
   * übergebenen Parameter festgelegt wird.
   *
   * @param n bestimmt Intervall {1, ..., n} für Operanden
   * @return Feld mit Multiplikationstabelle; Feld besitzt n Komponenten, i-te Komponente enthält
   *         Feld mit i+1 int-Komponenten
   */
  private static int[][] erzeugeProduktDreieck(int n) {

    /*
     * Feld erzeugen. Die Komponenten des Felds werden später erzeugt.
     */
    int[][] dreieck = new int[n][];

    for (int i = 0; i < n; i = i + 1) {

      /*
       * i-te Komponente des Dreiecks erzeugen. Die i-te Komponente ist ein int-Feld der Länge i +
       * 1.
       */
      dreieck[i] = new int[i + 1];

      /*
       * Multiplikationen ausführen und Ergebnisse in int-Feld speichern.
       */
      for (int j = 0; j <= i; j = j + 1) {
        dreieck[i][j] = (i + 1) * (j + 1);
      }
    }

    return dreieck;
  }

  /**
   * Führt Testmethoden aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    /*
     * Feld mit 2 Komponenten, jede ein Feld mit 4 Komponenten
     */
    zeigeDimensionen(new int[2][4]);

    /*
     * Feld mit 2 Komponenten, jede ein Feld mit 0 Komponenten
     */
    zeigeDimensionen(new int[2][0]);

    /*
     * Feld mit 4 Komponenten, i-te davon ein Feld mit i Komponenten
     */
    int[][] feld = new int[4][];
    feld[0] = new int[0];
    feld[1] = new int[1];
    feld[2] = new int[2];
    feld[3] = new int[3];
    zeigeDimensionen(feld);

    /*
     * Das gleiche mit Initialisierungsliste
     */
    zeigeDimensionen(new int[][]{new int[0], new int[1],
      new int[2], new int[3]});

    zeigeMatrix(erzeugeProduktMatrix(4, 7));
    zeigeMatrix(erzeugeProduktDreieck(7));
  }
}
ava

```

## Rechteck
```java

/**
 * Ein Objekt dieser Klasse repräsentiert ein Rechteck in einer 2D-Ebene. Die
 * Seiten des Rechtecks liegen parallel bzw. senkrecht zur horizontalen und
 * vertikalen Koordinaten-Achse.
 */
public class Rechteck {

  /**
   * Ursprung, d.h. linke obere Ecke dieses Rechtecks.
   */
  private Punkt ursprung;

  /**
   * Breite dieses Rechtecks.
   */
  private double breite;

  /**
   * Höhe dieses Rechtecks.
   */
  private double hoehe;

  /**
   * Erzeugt ein Rechteck, dessen Breite und Höhe 0 ist. Der Ursprung des Rechtecks ist der Punkt
   * (0, 0).
   */
  public Rechteck() {

    this.ursprung = new Punkt(0, 0);
    this.breite = 0;
    this.hoehe = 0;

  }

  /**
   * Erzeugt ein Rechteck mit der angegebenen Breite und Höhe. Der Ursprung liegt bei (0, 0).
   *
   * @param breite Breite dieses Rechtecks
   * @param hoehe  Höhe dieses Rechtecks
   */
  public Rechteck(double breite, double hoehe) {

    this.ursprung = new Punkt(0, 0);
    this.breite = breite;
    this.hoehe = hoehe;
  }

  /**
   * Erzeugt ein Rechteck mit den angegebenen Koordinaten.
   *
   * @param x      horizontaler Ursprung dieses Rechtecks
   * @param y      vertikaler Ursprung dieses Rechtecks
   * @param breite Breite dieses Rechtecks
   * @param hoehe  Höhe dieses Rechtecks
   */
  public Rechteck(double x, double y, double breite, double hoehe) {

    this.ursprung = new Punkt(x, y);
    this.breite = breite;
    this.hoehe = hoehe;
  }

  /**
   * Prüft, ob der übergebene Punkt innerhalb dieses Rechtecks oder auf dessen Begrenzungslinien
   * liegt.
   *
   * @param punkt Punkt
   * @return {@code true} genau dann, wenn der Punkt innerhalb dieses Rechtecks oder auf seinen
   *         Begrenzungslinien liegt
   */
  public boolean enthaeltPunkt(Punkt punkt) {

    return (this.ursprung.gibX() <= punkt.gibX()
            && punkt.gibX() <= this.ursprung.gibX() + this.breite
            && this.ursprung.gibY() <= punkt.gibY()
            && punkt.gibY() <= this.ursprung.gibY() + this.hoehe);

    /*
     * so geht's auch:
     */
    // Punkt eckpunkt = ursprung.gibVersetztenPunkt(this.breite,
    //                                              this.hoehe);
    // return (this.ursprung.istRechtsUnterhalb(punkt)
    //         && punkt.istRechtsUnterhalb(eckpunkt));
  }

  /**
   * Liefert die Fläche dieses Rechtecks.
   *
   * @return Fläche dieses Rechtecks
   */
  public double gibFlaeche() {

    return this.breite * this.hoehe;
  }

  /**
   * Vergrößert dieses Rechteck um den angegebenen Faktor.
   *
   * @param faktor Faktor, um den das Rechteck vergrößert wird
   */
  public void vergroessere(double faktor) {

    this.breite = faktor * this.breite;
    this.hoehe = faktor * this.hoehe;
  }

  /**
   * Verschiebt dieses Rechteck um das angegebene Mass in horizontaler und vertikaler Richtung.
   *
   * @param xVerschiebung Verschiebung in horizontaler Richtung; durch Wert größer 0 wird nach
   *                      rechts verschoben
   * @param yVerschiebung Verschiebung in vertikaler Richtung; durch Wert größer 0 wird nach unten
   *                      verschoben
   */
  public void verschiebe(int xVerschiebung, int yVerschiebung) {

    this.ursprung.verschiebe(xVerschiebung, yVerschiebung);
  }

  /**
   * Liefert das kleinste Rechteck, das dieses und das übergebene Rechteck umhüllt. Beide Rechtecke
   * bleiben unverändert.
   *
   * @param rechteck ein Rechteck
   * @return kleinstes Rechteck, das dieses Rechteck und {@code rechteck} umhüllt
   */
  public Rechteck erzeugeHuelle(Rechteck rechteck) {

    /*
     * Minimale und maximale horizontale und vertikale Koordinaten beider Rechtecke bestimmen.
     */
    double xMin = Math.min(this.ursprung.gibX(), rechteck.ursprung.gibX());
    double yMin = Math.min(this.ursprung.gibY(), rechteck.ursprung.gibY());

    double xMax = Math.max(this.ursprung.gibX() + this.breite,
            rechteck.ursprung.gibX() + rechteck.breite);
    double yMax = Math.max(this.ursprung.gibY() + this.hoehe,
            rechteck.ursprung.gibY() + rechteck.hoehe);

    return new Rechteck(xMin, yMin, xMax - xMin, yMax - yMin);
  }

  /**
   * Liefert eine textuelle Repräsentation dieses Rechtecks.
   *
   * @return textuelle Repräsentation dieses Rechtecks mit Angabe seiner Koordinaten
   */
  public String gibAlsString() {

    return "Rechteck (Ursprung = "
            + this.ursprung.gibAlsString()
            + ", Breite = " + this.breite
            + ", Höhe = " + this.hoehe + ")";
  }

  /**
   * Veranschaulicht Zugriffe auf Instanzvariablen der Klasse Rechteck.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    /*
     * Variablen deklarieren, die in den folgenden Testanweisungen benötigt werden.
     */
    Rechteck r1;
    Rechteck r2;

    r1 = new Rechteck(1, 2, 3, 4);

    /*
     * Instanzvariable dieses Rechtecks in Ausdrücken verwenden. Wichtig: der Zugriff auf *private*
     * Instanzvariablen einer Klasse ist nur aus Methoden dieser Klasse möglich. Der Programm, der
     * hier gezeigt wird, wäre z.B. in der Klasse RechteckTest nicht möglich.
     */
    System.out.println(r1.breite);
    System.out.println((r1.breite + r1.hoehe) / 2);

    /*
     * Instanzvariablen dieses Rechtecks Werte zuweisen.
     */
    r1.breite = 4.5;
    System.out.println(r1.breite);

    /*
     * Zuweisung an Instanzvariable hat Effekt nur für genau das Objekt, dessen Variable man
     * anspricht.
     */
    r1 = new Rechteck(1.5, 1);
    r2 = new Rechteck(2.5, 2);
    r1.breite = 15.5;
    r2.breite = 10.3;
    System.out.println(r1.breite);  // Ausgabe: 15.5
    System.out.println(r2.breite);  // Ausgabe 10.3

    /*
     * Ähnlicher Code, aber mit "Seiteneffekt". Beachte: zwei Variablen können dasselbe Objekt
     * enthalten.
     */
    r1 = new Rechteck(1.5, 1);
    r2 = new Rechteck(2.5, 2);
    r1.breite = 15.5;
    r2 = r1;
    r2.breite = 10.3;
    System.out.println(r2.breite);  // Ausgabe 10.3
    System.out.println(r1.breite);  // Ausgabe auch 10.3!

    /*
     * Der Objektausdruck vor dem Punkt muss keine Variable sein. Es ist jeder Ausdruck erlaubt, der
     * ein entsprechendes Objekt als Wert liefert. Aber: Typen müssen beachtet werden! Hat der
     * Objektausdruck den Typ T (wobei T eine Klasse ist), dann sind nur Instanzvariablen rechts vom
     * Punkt (.) zulässig, die in der Klasse T bekannt sind. Dies heißt zunächst, die
     * Instanzvariablen müssen in der Klasse T definiert sein.
     */
    System.out.println((new Rechteck(1, 2, 3, 4)).breite);
  }
}

```

## VariableParameterlisten
```java

/**
 * Diese Klasse gibt Code-Beispiele für:
 * <ul>
 * <li>variable Parameterlisten</li>
 * <li>erweiterte for-Schleife über Felder</li>
 * </ul>.
 */
public class VariableParameterlisten {

  /**
   * Liefert das Minimum der übergebenen Werte. Es wird vorausgesetzt, dass die Länge des Felds
   * mindestens 1 ist.
   *
   * @param werte Werte, deren Minimum berechnet wird
   * @return Minimum der übergebenen Werte
   */
//  private static int minimum(int[] werte) {
//
//    int minimum = werte[0];
//    for (int i = 1; i < werte.length; i++) {
//      minimum = Math.min(minimum, werte[i]);
//    }
//    return minimum;
//  }

  /*
   * Zweite Variante dieser Methode: Der Typ double... steht für den Typ double[], und so wird auch
   * auf die Werte zugegriffen. Den Unterschied zwischen beiden Typangaben sieht man bei Anwendung
   * der Methode.
   */
  /**
   * Liefert das Minimum der übergebenen Werte. Es wird vorausgesetzt, dass mindestens ein Wert
   * übergeben wird.
   *
   * @param werte Werte, deren Minimum berechnet wird
   * @return Minimum der übergebenen Werte
   */
  private static int minimum(int... werte) {

    int minimum = werte[0];
    for (int i = 1; i < werte.length; i++) {
      minimum = Math.min(minimum, werte[i]);
    }
    return minimum;
  }

  /*
   * Verwendet man zwei formale Parameter, kann man sicherstellen, dass mindestens ein Wert für die
   * Maximum-Berechnung übergeben wird. Bei Anwendung der Methode sieht man keinen Unterschied zur
   * zweiten Variante der minimum-Methode. Eine Methode kann höchstens einen formaler Parameter
   * variabler Länge besitzen, und dies muss der letzte sein.
   */
  /**
   * Liefert das Maximum der übergebenen Werte.
   *
   * @param wert  erster Wert der Berechnung
   * @param werte weitere Werte, deren Maximum berechnet wird
   * @return Maximum der übergebenen Werte
   */
  private static int maximum(int wert, int... werte) {

    int maximum = wert;
    for (int w : werte) {
      maximum = Math.max(maximum, w);
    }
    return maximum;
  }

  /**
   * Ruft Testmethoden auf.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    /*
     * Diese Methode geht für beide Varianten der minimum-Methode: Die mit Feld-Parameter, und die
     * mit variabler Parameterliste.
     */
    System.out.println(minimum(new int[]{2, 1, -1, 4}));

    /*
     * Dieser Aufruf funktioniert nur, wenn die Methode eine variable Parameterliste hat.
     */
    System.out.println(minimum(2, 1, -1, 4));

    /*
     * Compilierbar, führt aber wegen Indexfehler zum Programmabbruch zur Laufzeit.
     */
    // System.out.println(minimum());
    System.out.println(maximum(2, 1, -1, 8));

    /*
     * Nicht compilierbar.
     */
    // System.out.println(maximum());
  }
}

```

