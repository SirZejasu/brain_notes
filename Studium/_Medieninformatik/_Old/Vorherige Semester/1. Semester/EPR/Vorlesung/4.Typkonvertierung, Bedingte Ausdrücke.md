#Medieninformatik 
#EPR 
#Vorlesung 

---
# Klausurrelevanz
- Unterschied Compilerzeit und Laufzeit. 
- Typenkonvertierung (Compiler / Laufzeit)
- 


# Rationale Zahlen

![[06_Rationale Zahlen.pdf]]

## Rationale Zahlen
- Fließkommazahlen, die als Bruch dargestellt werden können.
- 

## Sonstiges
- Int-Arithmeik

## Code-Beispiel
```js
/**
 * Diese Klasse gibt Code-Beispiele für rationale Zahlen.
 * <ul>
 * <li>Notation von Werten der Gleitkomma-Typen im Quellcode</li>
 * <li>Anwendung von einigen Operatoren</li>
 * </ul>
 */
public class RationaleZahlen {

  /**
   * Gibt konstante Werte und Berechnungen für Gleitkommatypen auf dem Bildschirm aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    /*
     * Konstanten vom Typ double
     */
    System.out.println(500.0);
    System.out.println(500d);
    System.out.println(0.5);
    System.out.println(-500.6);
    System.out.println(5E-2);  // 0.05
    System.out.println(0.5E3);  // 500.0
    System.out.println(4.711E3);  // 4711.0

    /*
     * Konstanten vom Typ float
     */
    System.out.println(500F);
    System.out.println(0.5F);
    System.out.println(4.711E10F);
    System.out.println(47110000000F);
    System.out.println();

    /*
     * Division zweier Gleitkommazahlen.
     */
    System.out.println(5.0 / 3.0);

    /*
     * Addition zweier Gleitkommazahlen, die mathematisch eine ganze Zahl ergibt. Java liefert bei
     * Verknüpfung zweier Gleitkommazahlen immmer eine Gleitkommazahl.
     */
    System.out.println(1.5 + 2.5);

    /*
     * Das gleiche bei der Subtraktion und Multiplikation.
     */
    System.out.println(356.5 - 56.5);
    System.out.println(0.25 * 4.0);

    /*
     * Das mathematisch korrekte Ergebnis dieser Berechnungen ist im Datentyp float nicht
     * darstellbar. Der erste Ausdruck liefert den Wert infinity, der zweite -infinity.
     */
    System.out.println(1.1E20 * 1.1E20);
    System.out.println(-1.1E20F * 1.1E20F);

    /*
     * Gleitkommadivision durch 0.0 liefert infinity oder -infinity, je nach Vorzeichen der
     * Operanden.
     */
    System.out.println(4.0 / 0.0);

    /*
     * Restwertoperator ist auch für Gleitkommazahlen anwendbar. Aber das Ergebnis muss nicht
     * mathematisch exakt sein.
     */
    System.out.println(2.8 % 0.5);

    /*
     * Arithmetik mit Gleitkommazahlen kann zu Ergebnissen führen, die vom mathematisch korrekten
     * Ergebnis abweichen. Alle folgenden Ausdrücke sollten 0 ergeben.
     */
    System.out.println(0.1 + 0.1 + 0.1 - 0.3);
    System.out.println(1000f - 1f / 0.001f);
    System.out.println(100000d - 1d / 0.00001);

    /*
     * ... und noch ein Beispiel für Rechenungenauigkeit
     */
    System.out.println(2354f * 0.01f);
  }
}
```



# Typkonvertierung
![[_Medieninformatik/Vorherige Semester/1. Semester/EPR/Vorlesung/Anhänge/07_Typkonvertierung.pdf]]

## Code-Beispiel
```js
/**
 * Diese Klasse führt mit Hilfe von Ausdrücken einfache Berechnungen durch und gibt die Ergebnisse
 * auf dem Bildschirm aus. Die Ausdrücke enthalten Operatoren zur Typkonvertierung. Der Zweck
 * dieser Klasse ist, Code-Beispiele für die Anwendung von expliziter und impliziter
 * Typkonvertierung zu zeigen.
 */
public class Typkonvertierung {

  /**
   * Führt die Berechnungen durch und gibt die Ergebnisse auf dem Bildschirm aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    /*
     * Explizite Typkonvertierung
     */

    /*
     * 3 wird in Typ double gewandelt.
     */
    System.out.println(2.5 + (double) 3);

    /*
     * 5 wird in Typ double gewandelt. Erst danach wird dividiert. Ergebnistyp ist double.
     */
    System.out.println(((double) 5) / 2.0);

    /*
     * Die Division ist geklammert. Erst wird dividiert, dann wird das Ergebnis in Typ double
     * gewandelt.
     */
    System.out.println((double) (5 / 2));

    /*
     * Bei der Konvertierung einer Gleitkommazahl in eine ganze Zahl wird der Nachkommaanteil
     * abgeschnitten.
     */
    System.out.println((int) 4.5);
    System.out.println((int) (5.1 + 3.0));

    /*
     * Bei der Konvertierung einer ganzen Zahl von einem breiteren in einen schmaleren Typ werden
     * von der internen Darstellung des Ausgangswerts die hintersten n Stellen abgeschnitten, wobei
     * n die interne Darstellungslänge des Zieltyps ist.
     */
    System.out.println((short) 0x0000FFFF);
    System.out.println((short) 0xFFFF0001);

    /*
     * Liegt eine Gleitkommazahl, die in eine ganze Zahl gewandelt werden soll, außerhalb des
     * Wertebereichs des ganzzahligen Typs, wird am größten bzw. kleinsten Wert dieses Typs
     * "abgeschnitten".
     */
    System.out.println((int) 2E9F);
    System.out.println((int) 1E10F);
    System.out.println((int) -1E10F);


    /*
     * Implizite Typkonvertierung
     */

    /*
     * Addition bewirkt einen Überlauf.
     */
    System.out.println(1_000_000_000 + 2_000_000_000);

    /*
     * Jetzt mit einem Operanden vom Typ long. Der andere Operand wird automatisch von int nach long
     * gewandelt. Die Operation wird im Wertebereich von long ausgeführt, deshalb kein Überlauf.
     */
    System.out.println(1_000_000_000 + 2_000_000_000L);

    /*
     * 2 wird in Typ des anderen Operanden, also double, gewandelt. Das Ergebnis der Operation ist
     * vom Typ double.
     */
    System.out.println(2.5 * 2);

    /*
     * Erst wird dividiert, Ergebnis 2, dann wird implizit in Typ des anderen Operanden, also
     * double, gewandelt. Das Ergebnis der Operation ist vom Typ double.
     */
    System.out.println(5 / 2 - 1.0);

    /*
     * Bei der Konvertierung von ganzzahligen in Gleitkommawerte kann Genauigkeit verloren gehen.
     */
    System.out.println(100_000_000_000L + 0F);

    /*
     * Wahrheitswerte lassen sich nicht in nummerische Typen konvertieren.
     */
    // System.out.println(true + 2);

    /*
     * Typverträgliche Zuweisungen, da Ausdrücke auf der rechten Seite sog. konstante Ausdrücke sind
     * und ihre Werte im Wertebereich der Variablentypen liegen.
     */
    short s = 100;
    byte b = 50 + 60;
  }
}
```


# Bedingte Ausdrücke
![[_Medieninformatik/Vorherige Semester/1. Semester/EPR/Vorlesung/Anhänge/08_Bedingte Ausdrücke.pdf]]

### Beispielcode
``` js
/**
 * Diese Klasse führt einfache Berechnungen mit Hilfe bedingter Ausdrücke durch.
 * Der Zweck dieser Klasse ist, Code-Beispiele für die Anwendung bedingter Ausdrücke zu zeigen.
 */
public class BedingteAusdruecke {

  /**
   * Führt die Berechnungen durch und gibt die Ergebnisse auf dem Bildschirm aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    /*
     * Ausdruck zur Berechnung des Betrags von a. Belegen Sie a mit positiven und negativen ganzen
     * Zahlen und beobachten Sie die Ausgabe.
     */
    int a = 5;
    System.out.println((a >= 0)
            ? a
            : -a);

    /*
     * Beispiel für zwei verschachtelte bedingte Ausdrücke. Wenn der Wert von a nicht größer als 0
     * ist, wird der Nein-Zweig ausgewertet. Dieser enthält wieder einen bedingten Ausdruck.
     */
    System.out.println((a > 0)
            ? 1
            : ((a == 0)
                    ? 0
                    : -1));

    /*
     * Bedingter Ausdruck, der Teil eines anderen Ausdrucks ist. Der gesamte Ausdruck berechnet 10
     * plus Betrag von a.
     */
    System.out.println(10 + ((a >= 0) ? a : -a));

    /*
     * Bedingter Ausdruck, bei dem die Typen des Ja- und Nein-Zweigs ungleich sind. Der Typ des
     * Ja-Zweigs (int) ist aber in den Typ des Nein-Zweigs (double) implizit konvertierbar, deshalb
     * ist der bedingte Ausdruck gültig. Sein Typ ist der breitere der beiden Typen, also double.
     */
    System.out.println((a >= 0) ? 2 : 2.5);

    /*
     * Da der Typ des bedingten Ausdrucks double ist, ist diese Zuweisung unzulassig.
     */
    // int b = (a >= 0) ? 5 : 2.5;
  }
}
```