#Vorlesung 
#EPR 
#Medieninformatik 

---
# Material
[[_Medieninformatik/Vorherige Semester/1. Semester/EPR/Vorlesung/Anhänge/15_Rekursive Datenstrukturen.pdf]]

# Summary
- <mark style="background: #BBFABBA6;">Klausurrelevant</mark>
	- Dauer: 120min
	- Aufgaben auf Papier
	- Keine Hilfsmittel
	- Themen aus Vorlesung und Programmierkonzepte und - techniken aus dem Praktikum
	- <mark style="background: #D2B3FFA6;">Umfassung der Klausur</mark>
		- 10 Aufgaben
		- <mark style="background: #FFB86CA6;">Ähnliche oder gleiche Aufgaben aus dem Modul (Übung, Praktikum, Vorlesung)</mark>
		- Anwenden von Konzepten
		- Kreative Anwendung von Konzepten und lösen einer Problemstellung

# SC Vorlesung
## Liste Rekursiv
```java
public String gibInhalt(int Index){
	return listenkopf != null
		? listenopf.gibInhalt(index);
		: null;
}
```

## Listenknoten
```java
public String gibInhalt (int index) {
	return index == 0
		? inhalt
			: nachfolger != null
				? nachfolger.gibInhalt (index -1)
				: null; // Fehler

}
```


# SC Beispiele
## Listeknoten
```java

/**
 * Ein Listenknoten repräsentiert einen Knoten einer einfach verketteten
 * Liste. Ein Knoten enthält einen Inhalt und einen Nachfolgeknoten.
 */
public class Listenknoten {

  /**
   * Inhalt dieses Knotens.
   */
  private final String inhalt;

  /**
   * Nachfolgender Listenknoten.
   */
  private Listenknoten nachfolger;

  /**
   * Erzeugt einen neuen Listenknoten mit der übergebenen Zeichenkette als Inhalt.
   *
   * @param inhalt Inhalt dieses Listenknotens
   */
  public Listenknoten(String inhalt) {

    this.inhalt = inhalt;
    this.nachfolger = null;
  }

  /**
   * Erzeugt einen neuen Listenknoten mit der übergebenen Zeichenkette als Inhalt und dem
   * übergebenen Knoten als Nachfolger.
   *
   * @param inhalt     Inhalt dieses Listenknotens
   * @param nachfolger Nachfolger dieses Listenknotens
   */
  public Listenknoten(String inhalt, Listenknoten nachfolger) {

    this.inhalt = inhalt;
    this.nachfolger = nachfolger;
  }

  /**
   * Liefert den Inhalt dieses Listenknotens.
   *
   * @return Inhalt dieses Listenknotens
   */
  public String gibInhalt() {

    return this.inhalt;
  }

  /**
   * Liefert den nachfolgenden Listenknoten.
   *
   * @return nachfolgender Listenknoten
   */
  public Listenknoten gibNachfolger() {

    return this.nachfolger;
  }

  /**
   * Weist diesem Listenknoten einen neuen Nachfolger zu.
   *
   * @param knoten Nachfolger dieses Listenknotens
   */
  public void setzeNachfolger(Listenknoten knoten) {

    this.nachfolger = knoten;
  }
}

```


## VerketteListe
```java

/**
 * Ein Objekt dieser Klasse repräsentiert eine einfach verkettete Liste von
 * Zeichenketten.
 */
public class VerketteteListe {

  /**
   * Erster Knoten in der Liste der verketteten Knoten.
   */
  private Listenknoten listenkopf;

  /**
   * Letzter Knoten in der Liste der verketteten Knoten.
   */
  private Listenknoten listenende;

  /**
   * Länge dieser Liste.
   */
  private int listenlaenge;

  /**
   * Erzeugt eine leere Liste.
   */
  public VerketteteListe() {

    this.listenkopf = null;
    this.listenende = null;
    this.listenlaenge = 0;
  }

  /**
   * Fügt eine Zeichenkette vorne in dieser Liste hinzu.
   *
   * @param inhalt Zeichenkette, die vorne hinzugefügt wird
   */
  public void fuegeVorneHinzu(String inhalt) {

    this.listenkopf = new Listenknoten(inhalt, this.listenkopf);

    if (this.listenende == null) {

      /*
       * Die Liste war leer. Neuer Knoten wird auch Listenende.
       */
      this.listenende = this.listenkopf;
    }

    this.listenlaenge = this.listenlaenge + 1;
  }

  /**
   * Fügt eine Zeichenkette hinten in dieser Liste hinzu.
   *
   * @param inhalt Zeichenkette, die hinten hinzugefügt wird
   */
  public void fuegeHintenHinzu(String inhalt) {

    if (this.listenkopf == null) {

      /*
       * Die Liste ist leer. Neuer Knoten wird Listenkopf und Listenende.
       */
      this.listenkopf = new Listenknoten(inhalt);
      this.listenende = this.listenkopf;

    } else {

      /*
       * Die Liste ist nicht leer. Neuer Knoten wird Listenende. Listenkopf bleibt unverändert.
       */
      Listenknoten knoten = new Listenknoten(inhalt);
      this.listenende.setzeNachfolger(knoten);
      this.listenende = knoten;
    }

    this.listenlaenge = this.listenlaenge + 1;
  }

  /**
   * Fügt eine Zeichenkette an der angegebenen Position in diese Liste ein.
   *
   * @param position Position, an der die Zeichenkette eingefügt wird. Wenn position == 0, wird
   *                 vorne eingefügt. Wenn position == 1, wird an zweiter Stelle eingefügt usw.
   * @param inhalt   Zeichenkette, die hinzugefügt wird
   */
  public void fuegeHinzu(int position, String inhalt) {

    if (position == 0) {
      fuegeVorneHinzu(inhalt);
    } else if (position == this.listenlaenge) {
      fuegeHintenHinzu(inhalt);
    } else if ((position > 0) && (position < this.listenlaenge)) {

      Listenknoten knoten = new Listenknoten(inhalt);

      /*
       * Der neue Knoten muss hinter dem Knoten an Position position - 1 eingefügt werden. Deshalb
       * die Liste durchlaufen, bis Variable k den Knoten an dieser Position enthält.
       */
      Listenknoten vorgaenger = this.listenkopf;
      for (int i = 1; i < position; i = i + 1) {
        vorgaenger = vorgaenger.gibNachfolger();
      }

      /*
       * Neuen Knoten als Nachfolger des Knotens an Position position - 1 (Wert der Variablen
       * vorgaenger) einfügen.
       */
      knoten.setzeNachfolger(vorgaenger.gibNachfolger());
      vorgaenger.setzeNachfolger(knoten);

      this.listenlaenge = this.listenlaenge + 1;
    }
  }

  /**
   * Fügt eine Zeichenkette an der angegebenen Position in diese Liste ein.
   *
   * Der Name dieser Methode ist schlecht gewählt. Es interessiert einen Aufrufer nicht, ob beim
   * Hinzufügen die Listenlänge ausgewertet wird oder nicht. Hier wird dieser Name gewählt, um diese
   * Methode von der Methode fuegeHinzu unterscheidbar zu machen. In der Praxis entscheidet man sich
   * für eine Realisierungsart.
   *
   * @param position Position, an der die Zeichenkette eingefügt wird. Wenn position == 0, wird
   *                 vorne eingefügt. Wenn position == 1, wird an zweiter Stelle eingefügt usw. Es
   *                 wird davon ausgegangen, dass die position nicht negativ ist.
   * @param inhalt   Zeichenkette, die hinzugefügt wird
   */
  public void fuegeHinzuOhneListenlaenge(int position, String inhalt) {

    if (position == 0) {

      /*
       * Knoten wird vorne hinzugefügt.
       */
      this.listenkopf = new Listenknoten(inhalt, this.listenkopf);

      if (this.listenende == null) {

        /*
         * Die Liste war leer. Neuer Knoten wird auch Listenende.
         */
        this.listenende = this.listenkopf;
      }

      this.listenlaenge = this.listenlaenge + 1;

    } else {

      /*
       * Knoten soll nicht vorne hinzugefügt werden.
       */

      /*
       * Zähler zur Ermittlung der Einfügeposition.
       */
      int positionszaehler = 1;

      /*
       * Knoten, hinter dem der neue Knoten eingefügt werden soll.
       */
      Listenknoten vorgaenger = this.listenkopf;

      /*
       * Denjenigen Knoten k suchen, hinter dem der neue Knoten eingefügt werden muss.
       */
      while ((positionszaehler < position) && (vorgaenger != null)) {
        positionszaehler = positionszaehler + 1;
        vorgaenger = vorgaenger.gibNachfolger();
      }

      /*
       * Falls vorgaenger == null, so ist die Einfügeposition für diese Liste ungültig.
       */
      if (vorgaenger != null) {

        /*
         * vorgaenger enthält den Knoten, hinter dem der neue Knoten eingefügt werden muss.
         */
        Listenknoten knoten
                = new Listenknoten(inhalt, vorgaenger.gibNachfolger());
        vorgaenger.setzeNachfolger(knoten);
        this.listenlaenge = this.listenlaenge + 1;

        /*
         * Ist der neue Knoten der letzte der Liste, muss das Listenende gesetzt werden.
         */
        if (knoten.gibNachfolger() == null) {
          this.listenende = knoten;
        }
      }
    }
  }

  /**
   * Fügt eine Zeichenkette an der ersten möglichen Stelle in diese Liste ein, sodass sie gleich der
   * darauffolgenden Zeichenkette ist oder lexikografisch vor ihr steht. Fügt man der Liste
   * Zeichenketten nur über diese Methode hinzu, so enthält sie die Zeichenketten in alphabetischer
   * Sortierung.
   *
   * @param inhalt Zeichenkette, die hinzugefügt wird
   */
  public void fuegeSortiertHinzu(String inhalt) {

    /*
     * Hier wird zu Zwecken der Anschauung eine Implementierung gewählt, in der von den Methoden
     * fuegeVorneHinzu und fuegeHintenHinzu kein Gebrauch gemacht wird.
     */

    /*
     * Neuen Knoten für inhalt erzeugen. Es ist noch unklar, wo dieser Knoten eingefügt werden muss.
     */
    Listenknoten knoten = new Listenknoten(inhalt);

    if (this.listenkopf == null) {

      /*
       * Die Liste ist leer. Neuer Knoten wird Listenkopf und Listenende.
       */
      this.listenkopf = knoten;
      this.listenende = this.listenkopf;

    } else {

      /*
       * Die Liste ist nicht leer.
       */

      /*
       * Liste vom Listenkopf an solange durchlaufen, bis der Inhalt eines Knotens (Variable
       * aktuellerKnoten) gleich der einzufügenden Zeichenkette ist oder alphabetisch hinter ihr
       * steht. Der neue Knoten muss dann VOR diesem Knoten eingefügt werden. Deshalb wird in einer
       * zweiten Variablen jeweils der Knoten mitgeführt, der vor dem aktuellen Knoten steht.
       */
      Listenknoten aktuellerKnoten = this.listenkopf;
      Listenknoten vorherigerKnoten = null;

      /*
       * Hinweis: Die Methode compareTo der Klasse String ermöglicht die Untersuchung, in welcher
       * lexikografischen Ordnung zwei Zeichenketten zueinander stehen. Ein String s1 ist
       * lexikografisch kleiner s2, wenn s1.compareTo(s2) < 0.
       */

      /*
       * Solange die Liste durchlaufen, wie noch nicht das Ende erreicht ist und der Inhalt des
       * aktuellen Knotens alphabetisch vor der einzufügenden Zeichenkette steht.
       */
      while ((aktuellerKnoten != null)
              && (aktuellerKnoten.gibInhalt().compareTo(inhalt) < 0)) {

        /*
         * Um einen Knoten weiterrücken.
         */
        vorherigerKnoten = aktuellerKnoten;
        aktuellerKnoten = aktuellerKnoten.gibNachfolger();
      }

      if (vorherigerKnoten == null) {

        /*
         * Die Schleife wurde nicht betreten. Der Knoten muss vorne eingefügt werden.
         */
        knoten.setzeNachfolger(this.listenkopf);
        this.listenkopf = knoten;

      } else {

        /*
         * Knoten wird nicht vorne eingefügt. Listenkopf bleibt unverändert. Knoten wird zwischen
         * vorherigerKnoten und aktuellerKnoten eingefügt.
         */
        vorherigerKnoten.setzeNachfolger(knoten);
        knoten.setzeNachfolger(aktuellerKnoten);

        /*
         * Listenende neu setzen, wenn Knoten als letzter Knoten eingefügt wurde.
         */
        if (aktuellerKnoten == null) {
          this.listenende = knoten;
        }
      }
    }
    this.listenlaenge = this.listenlaenge + 1;
  }

  /**
   * Entfernt die Zeichenkette an der angegebenen Position aus dieser Liste.
   *
   * @param index Index der Zeichenkette, die entfernt werden soll
   */
  public void entferne(int index) {

    if ((index >= 0) && (index < this.listenlaenge)) {

      /*
       * Es soll ein Element aus dem gültigen Indexbereich entfernt werden.
       */
      if (index == 0) {

        /*
         * Die Liste ist nicht leer und es soll der erste Knoten entfernt werden.
         */
        this.listenkopf = this.listenkopf.gibNachfolger();

        /*
         * Enthielt die Liste zuvor nur einen Knoten, so ist anschließend auch das Listenende die
         * null-Referenz.
         */
        if (this.listenkopf == null) {
          this.listenende = null;
        }

        this.listenlaenge = this.listenlaenge - 1;

      } else {

        /*
         * Die Liste ist nicht leer und es wird ein mittlerer oder der letzte Knoten entfernt.
         */

        /*
         * Durch die Liste laufen, sodass anschließend aktuellerKnoten den Knoten enthält, der
         * entfernt werden soll, und vorherigerKnoten seinen Vorgänger.
         */
        Listenknoten aktuellerKnoten = this.listenkopf;
        Listenknoten vorherigerKnoten = null;
        for (int i = 0; i < index; i = i + 1) {
          vorherigerKnoten = aktuellerKnoten;
          aktuellerKnoten = aktuellerKnoten.gibNachfolger();
        }

        /*
         * Der Knoten wird entfernt, indem sein Nachfolger zum Nachfolger des Vorgängers wird.
         */
        vorherigerKnoten.setzeNachfolger(
                aktuellerKnoten.gibNachfolger());

        /*
         * Wurde der letzte Knoten entfernt, muss das Listenende aktualisiert werden.
         */
        if (vorherigerKnoten.gibNachfolger() == null) {
          this.listenende = vorherigerKnoten;
        }

        this.listenlaenge = this.listenlaenge - 1;
      }
    }
  }

  /**
   * Verkettet die übergebene Liste mit dieser Liste. Es wird keine Kopie der übergebenen Liste
   * erstellt.
   *
   * @param liste Liste, die mit dieser Liste verkettet werden soll
   */
  public void verkette(VerketteteListe liste) {

    if (this.listenkopf == null) {

      /*
       * Diese Liste ist leer. Der Kopf der anzuhängenden Liste wird Kopf der verketteten Liste.
       */
      this.listenkopf = liste.listenkopf;

    } else {

      /*
       * Diese Liste ist nicht leer. Der Kopf der anzuhängenden Liste wird an das Ende dieser Liste
       * angefügt.
       */
      this.listenende.setzeNachfolger(liste.listenkopf);
    }

    /*
     * Listenende der anzuhängenden Liste wird zum Listenende dieser Liste, wenn die anzuhängende
     * Liste nicht leer ist.
     */
    if (liste.listenkopf != null) {
      this.listenende = liste.listenende;
    }

    /*
     * Längen der Listen addieren sich.
     */
    this.listenlaenge = this.listenlaenge + liste.listenlaenge;
  }

  /**
   * Liefert die Zeichenkette an der angegebenen Position in der Liste. Ist der Index ungültig, wird
   * null zurückgegeben.
   *
   * @param index Index der Zeichenkette
   * @return Zeichenkette an der angegebenen Position
   */
  public String gibInhalt(int index) {

    String inhalt;

    /*
     * Realisierung, bei der anhand der Listenlänge die Gültigkeit des Index geprüft wird.
     */
    if ((index < 0) || (index >= this.listenlaenge)) {
      // Fehlerfall: muss geeignet behandelt werden
      inhalt = null;
    } else {

      /*
       * Solange die Liste durchlaufen, bis k den angegebenen Listenknoten enthält.
       */
      Listenknoten k = this.listenkopf;
      for (int i = 0; i < index; i++) {
        k = k.gibNachfolger();
      }
      inhalt = k.gibInhalt();
    }
    return inhalt;

    /*
     * Alternative Realisierung, bei der sich während der Iteration ergibt, ob der Index gültig ist.
     */
//    Listenknoten k = index < 0 ? null : this.listenkopf;
//    int i = 0;
//
//    while (k != null && i < index) {
//        k = k.gibNachfolger();
//        i++;
//    }
//
//    return k == null ? null : k.gibInhalt();
  }

  /**
   * Liefert die Länge dieser Liste.
   *
   * @return Länge der Liste
   */
  public int gibLaenge() {

    return this.listenlaenge;
  }

  /**
   * Liefert String-Darstellung der Liste im Format
   * <pre>
   * Listenkopf: k; Listenende: e; Listeninhalt: i
   * </pre> Die String-Darstellung ist so gewählt, dass sie interne Details der Liste zu
   * Anschauungszwecken zeigt. k ist "null", wenn der Listenkopf die null-Referenz ist, sonst der
   * Inhalt des Kopfknotens. e ist "null", wenn das Listenende die null-Referenz ist, sonst der
   * Inhalt des Ende-Knotens. i ist durch Leerzeichen getrennt die Folge der Knoteninhalte.
   *
   * @return String-Darstellung dieser Liste
   */
  public String gibAlsString() {

    String ergebnis = "Listenkopf: "
            + ((this.listenkopf == null)
                    ? "null"
                    : this.listenkopf.gibInhalt())
            + "; ";

    ergebnis = ergebnis + "Listenende: "
            + ((this.listenende == null)
                    ? "null"
                    : this.listenende.gibInhalt())
            + "; ";

    ergebnis = ergebnis + "Listeninhalt:";

    Listenknoten k = this.listenkopf;

    /*
     * Inhalte aller Knoten aneinanderfügen.
     */
    while (k != null) {
      ergebnis = ergebnis + " " + k.gibInhalt();
      k = k.gibNachfolger();
    }

    return ergebnis;
  }
}

```


## VerketteListeTest
```java

/**
 * Diese Klasse veranschaulicht die Verwendung der Klasse VerketteteListe.
 */
public class VerketteteListeTest {

  /**
   * Testet Hinzufügen von Daten zur Liste.
   */
  private static void testeHinzufuegen() {

    VerketteteListe liste = new VerketteteListe();

    System.out.println(liste.gibAlsString());

    liste.fuegeHinzu(0, "Erfolg");
    liste.fuegeHintenHinzu("neuen");
    liste.fuegeHinzu(1, "im");
    liste.fuegeVorneHinzu("Viel");
    liste.fuegeHintenHinzu("Jahr");

    System.out.println(liste.gibAlsString());

    // Aufrufe mit ungültigen Indizes
    liste.fuegeHinzu(-1, "...");
    liste.fuegeHinzu(6, "....");

    System.out.println(liste.gibAlsString());
  }

  /**
   * Testet sortiertes Hinzufügen von Daten zur Liste.
   */
  private static void testeSortiertesHinzufuegen() {

    VerketteteListe liste = new VerketteteListe();

    liste.fuegeSortiertHinzu("Erfolg");
    liste.fuegeSortiertHinzu("neuen");
    liste.fuegeSortiertHinzu("im");
    liste.fuegeSortiertHinzu("Viel");
    liste.fuegeSortiertHinzu("Jahr");

    System.out.println(liste.gibAlsString());
  }

  /**
   * Erzeugt eine Liste mit 5 Knoten, um bei Tests von Methoden mit einer "gefüllten" Liste arbeiten
   * zu können.
   *
   * @return Liste mit Knoten für die Zeichenketten "Erfolg", "neuen", "im", "Viel", "Jahr"
   */
  private static VerketteteListe erzeugeListe() {

    VerketteteListe liste = new VerketteteListe();

    liste.fuegeHintenHinzu("Viel");
    liste.fuegeHintenHinzu("Erfolg");
    liste.fuegeHintenHinzu("im");
    liste.fuegeHintenHinzu("neuen");
    liste.fuegeHintenHinzu("Jahr");

    return liste;
  }

  /**
   * Testet Entfernen von Daten aus Liste.
   */
  private static void testeEntfernen() {

    VerketteteListe liste = erzeugeListe();

    System.out.println(liste.gibAlsString());

    liste.entferne(-1);
    System.out.println(liste.gibAlsString());

    liste.entferne(5);
    System.out.println(liste.gibAlsString());

    liste.entferne(0);
    System.out.println(liste.gibAlsString());

    liste.entferne(3);
    System.out.println(liste.gibAlsString());

    liste.entferne(1);
    System.out.println(liste.gibAlsString());

    liste.entferne(1);
    System.out.println(liste.gibAlsString());

    liste.entferne(0);
    System.out.println(liste.gibAlsString());
  }

  /**
   * Testet Verketten von Listen.
   */
  private static void testeVerketten() {

    /*
     * Testfall 1: nur erste Liste ist leer.
     */
    VerketteteListe liste = new VerketteteListe();
    liste.verkette(erzeugeListe());
    System.out.println(liste.gibAlsString());

    /*
     * Testfall 2: nur zweite Liste ist leer.
     */
    liste = erzeugeListe();
    liste.verkette(new VerketteteListe());
    System.out.println(liste.gibAlsString());

    /*
     * Testfall 3: beide Listen sind leer.
     */
    liste = new VerketteteListe();
    liste.verkette(new VerketteteListe());
    System.out.println(liste.gibAlsString());

    /*
     * Testfall 2: beide Listen sind nicht leer
     */
    liste = erzeugeListe();
    liste.verkette(erzeugeListe());
    System.out.println(liste.gibAlsString());
  }

  /**
   * Ruft Testmethoden auf.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    testeHinzufuegen();
    testeSortiertesHinzufuegen();
    testeEntfernen();
    testeVerketten();
  }
}

```

## StringTokenizer
```java
/**
 * Diese Klasse veranschaulicht die Funktionsweise der Klasse
 * StringTokenizer.
 */
public class StringTokenizerTest {

  /**
   * Gibt alle Wörter aus, die über den Tokenizer zugreifbar sind.
   *
   * @param tokenizer Tokenizer für Zugriff auf Wörter
   */
  private static void gibAlleWoerterAus(java.util.StringTokenizer tokenizer) {

    System.out.println("Anzahl: " + tokenizer.countTokens());

    while (tokenizer.hasMoreTokens()) {
      System.out.println(tokenizer.nextToken());
    }

    System.out.println("Anzahl: " + tokenizer.countTokens());
    System.out.println();
  }

  /**
   * Ausgabe der Wörter einer Zeichenkette mit verschiedenen Trennzeichen.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    java.util.StringTokenizer tokenizer;

    tokenizer = new java.util.StringTokenizer("Katz und Maus.");
    gibAlleWoerterAus(tokenizer);

    tokenizer = new java.util.StringTokenizer("Katz und Maus.", "au");
    gibAlleWoerterAus(tokenizer);

    tokenizer = new java.util.StringTokenizer("Katz und Maus.", "au", true);
    gibAlleWoerterAus(tokenizer);
  }
}
```

## Binärer Baum
### Baumknoten
```java

/**
 * Ein Baumknoten repräsentiert einen Knoten eines binären Suchbaums. Ebenso
 * repräsentiert er den durch diesen Knoten aufgespannten Baum. Ein Knoten
 * enthält als Inhalt eine Zeichenkette.
 */
public class Baumknoten {

  /**
   * Zeichen für Zeilenumbruch in Strings.
   */
  private static final char ZEILENUMBRUCH = '\n';

  /**
   * Einzelner Einrückungsschritt für Textdarstellung der Baum-Traversierung.
   */
  private static final String INDENT = "    ";

  /**
   * Inhalt dieses Knotens.
   */
  private String inhalt;

  /**
   * Linker Teilbaum dieses Knotens.
   */
  private Baumknoten linkerTeilbaum;

  /**
   * Rechter Teilbaum dieses Knotens.
   */
  private Baumknoten rechterTeilbaum;

  /**
   * Erzeugt einen neuen Baumknoten für den übergebenen Inhalt. Der Knoten ist ein Blatt.
   *
   * @param inhalt Wert, für den der Baumknoten erzeugt wird
   */
  public Baumknoten(String inhalt) {

    this.inhalt = inhalt;
    this.linkerTeilbaum = null;
    this.rechterTeilbaum = null;
  }

  /**
   * Liefert den Inhalt dieses Baumknotens.
   *
   * @return Inhalt dieses Baumknotens
   */
  public String gibInhalt() {

    return this.inhalt;
  }

  /**
   * Liefert den linken Teilbaum dieses Knotens.
   *
   * @return linker Teilbaum
   */
  public Baumknoten gibLinkenTeilbaum() {

    return this.linkerTeilbaum;
  }

  /**
   * Liefert den rechten Teilbaum dieses Knotens.
   *
   * @return rechter Teilbaum
   */
  public Baumknoten gibRechtenTeilbaum() {

    return this.rechterTeilbaum;
  }

  /**
   * Weist diesem Knoten einen linken Teilbaum zu.
   *
   * @param knoten Knoten, der linkes Kind dieses Knotens wird
   */
  public void setzeLinkenTeilbaum(Baumknoten knoten) {

    this.linkerTeilbaum = knoten;
  }

  /**
   * Weist diesem Knoten einen rechten Teilbaum zu.
   *
   * @param knoten Knoten, der rechtes Kind dieses Knotens wird
   */
  public void setzeRechtenTeilbaum(Baumknoten knoten) {

    this.rechterTeilbaum = knoten;
  }

  /**
   * Gibt die Inhalte der Inorder-Traversierung des Baums, der durch diesen Knoten aufgespannt wird,
   * zurück.
   *
   * @return Inhalte der Inorder-Traversierung, jeweils ein Knoteninhalt pro Zeile
   */
  public String gibInorderfolge() {

    return ((this.linkerTeilbaum == null)
            ? ""
            : this.linkerTeilbaum.gibInorderfolge() + ZEILENUMBRUCH)
            + this.inhalt
            + ((this.rechterTeilbaum == null)
                    ? ""
                    : ZEILENUMBRUCH + this.rechterTeilbaum.gibInorderfolge());
  }

  /**
   * Gibt die Inhalte der Preorder-Traversierung des Baums, der durch diesen Knoten aufgespannt
   * wird, zurück.
   *
   * @return Inhalte der Preorder-Traversierung, jeweils ein Knoteninhalt pro Zeile; Einrückung
   *         macht die Baumstruktur deutlich
   */
  public String gibPreorderfolge() {

    return gibPreorderfolge("");
  }

  /**
   * Durchläuft den Baum mit diesem Knoten als Wurzel in Preorder-Reihenfolge und liefert die
   * Preorder-Folge in eingerückter Form. Leere Bäume haben streng genommen eine leere
   * Preorder-Folge. Damit ersichtlich ist, wo sich im Baum leere Teilbäume befinden, wird für sie
   * der Text "(leer)" zurückgegeben.
   *
   * @param einrueckung Einrückung für diesen Knoten und seine Kinder
   */
  private String gibPreorderfolge(String einrueckung) {

    return (einrueckung + this.inhalt + ZEILENUMBRUCH)
            + ((this.linkerTeilbaum == null)
                    ? (INDENT + einrueckung + "(leer)")
                    : this.linkerTeilbaum.gibPreorderfolge(
                            INDENT + einrueckung))
            + ZEILENUMBRUCH
            + ((this.rechterTeilbaum == null)
                    ? (INDENT + einrueckung + "(leer)")
                    : this.rechterTeilbaum.gibPreorderfolge(
                            INDENT + einrueckung));
  }

  /**
   * Fügt dem Suchbaum mit diesem Knoten als Wurzel einen neuen Knoten für den übergebenen Wert
   * hinzu. Der Knoten wird so hinzugefügt, dass der Baum ein Suchbaum bleibt.
   *
   * @param wert Wert, der dem Baum hinzugefügt wird
   */
  public void fuegeHinzu(String wert) {

    if (wert.compareTo(this.inhalt) <= 0) {

      /*
       * Der Wert ist gleich dem Inhalt dieses Knotens oder liegt alphabetisch davor. Der Wert wird
       * im linken Teilbaum hinzugefügt.
       */
      if (this.linkerTeilbaum == null) {
        this.linkerTeilbaum = new Baumknoten(wert);
      } else {
        this.linkerTeilbaum.fuegeHinzu(wert);
      }

    } else {

      /*
       * Der Wert liegt alphabetisch hinter dem Inhalt dieses Knotens. Der Wert wird im rechten
       * Teilbaum hinzugefügt.
       */
      if (this.rechterTeilbaum == null) {
        this.rechterTeilbaum = new Baumknoten(wert);
      } else {
        this.rechterTeilbaum.fuegeHinzu(wert);
      }
    }
  }

  /**
   * Liefert den maximalen Inhalt aller Knoten des Suchbaums mit diesem Knoten als Wurzel.
   *
   * @return Maximaler Wert dieses Suchbaums
   */
  private String gibMaximalenWert() {

    return (this.rechterTeilbaum == null)
            ? this.inhalt
            : this.rechterTeilbaum.gibMaximalenWert();
  }

  /**
   * Entfernt aus dem Baum mit diesem Knoten als Wurzel den Knoten mit dem maximalen Inhalt.
   *
   * @return Baum ohne den Knoten mit maximalem Inhalt
   */
  private Baumknoten entferneMaximalenWert() {

    /*
     * Wurzelknoten nach dem Entfernen des Werts.
     */
    Baumknoten neueWurzel;

    if (this.rechterTeilbaum == null) {

      /*
       * Rechter Teilbaum ist leer. Wurzel enthält also maximalen Wert.
       */
      neueWurzel = this.linkerTeilbaum;

    } else {

      /*
       * Rechter Teilbaum ist nicht leer. Maximales Element ist also im rechten Teilbaum und wird
       * dort entfernt. Der resultierende Baum wird neuer rechter Teilbaum.
       */
      this.rechterTeilbaum = this.rechterTeilbaum.entferneMaximalenWert();
      neueWurzel = this;
    }

    return neueWurzel;
  }

  /**
   * Entfernt aus dem Suchbaum mit diesem Knoten als Wurzel den angegebenen Wert, sofern er im Baum
   * existiert.
   *
   * @param wert Wert, der aus dem Suchbaum entfernt wird (sofern er überhaupt existiert)
   * @return Baum nach Entfernen des Werts
   */
  public Baumknoten entferne(String wert) {

    /*
     * Wurzelknoten nach dem Entfernen des Werts.
     */
    Baumknoten neueWurzel = this;

    if ((wert.compareTo(this.inhalt) < 0)
            && (this.linkerTeilbaum != null)) {

      /*
       * Wert liegt alphabetisch vor dem Inhalt dieses Knotens. Das Entfernen wird im linken
       * Teilbaum durchgeführt.
       */
      this.linkerTeilbaum = this.linkerTeilbaum.entferne(wert);

    } else if ((wert.compareTo(this.inhalt) > 0)
            && (this.rechterTeilbaum != null)) {

      /*
       * Wert liegt alphabetisch hiner dem Inhalt dieses Knotens. Das Entfernen wird im rechten
       * Teilbaum durchgeführt.
       */
      this.rechterTeilbaum = this.rechterTeilbaum.entferne(wert);

    } else if (wert.equals(this.inhalt)) {

      /*
       * Wert ist gleich dem Inhalt dieses Knotens. Dieser Knoten wird entfernt.
       */
      if (this.rechterTeilbaum == null) {

        /*
         * Baum ohne diesen Knoten ist der linke Teilbaum, da der rechte leer ist.
         */
        neueWurzel = this.linkerTeilbaum;

      } else if (this.linkerTeilbaum == null) {

        /*
         * Baum ohne diesen Knoten ist der rechte Teilbaum, da der linke leer ist.
         */
        neueWurzel = this.rechterTeilbaum;

      } else {

        /*
         * Beide Teilbäume sind nicht leer. Der größte Inhalt des linken Teilbaums wird zum Inhalt
         * dieses Knotens. Der entsprechende Knoten aus dem linken Teilbaum wird entfernt.
         */
        this.inhalt = this.linkerTeilbaum.gibMaximalenWert();
        this.linkerTeilbaum
                = this.linkerTeilbaum.entferneMaximalenWert();
      }
    }

    return neueWurzel;
  }

  /**
   * Gibt an, ob der übergebene Wert im Baum enthalten ist.
   *
   * @param wert Wert, für den geprüft wird, ob er im Suchbaum enthalten ist
   * @return {@code true} genau dann, wenn der Wert enthalten ist
   */
  public boolean istEnthalten(String wert) {

    boolean istEnthalten;

    if (wert.compareTo(this.inhalt) < 0) {

      /*
       * Wert ist kleiner als Inhalt dieses Knotens. Falls Wert enthalten ist, ist er im linken
       * Teilbaum.
       */
      istEnthalten = (this.linkerTeilbaum != null)
              && linkerTeilbaum.istEnthalten(wert);

    } else if (wert.compareTo(this.inhalt) > 0) {

      /*
       * Wert ist größer als Inhalt dieses Knotens. Falls Wert enthalten ist, ist er im rechten
       * Teilbaum.
       */
      istEnthalten = (this.rechterTeilbaum != null)
              && rechterTeilbaum.istEnthalten(wert);

    } else {

      /*
       * Wert ist in diesem Knoten enthalten.
       */
      istEnthalten = true;
    }

    return istEnthalten;
  }
}


```

### Binärer Suchbaum
```java

/**
 * Ein Objekt dieser Klasse repräsentiert einen binären Suchbaum, dessen Knoten
 * Zeichenketten enthalten.
 */
public class BinaererSuchbaum {

  /**
   * Wurzelknoten dieses Suchbaums.
   */
  private Baumknoten wurzel;

  /**
   * Erzeugt einen leeren Suchbaum.
   */
  public BinaererSuchbaum() {

    this.wurzel = null;
  }

  // Traversierungen --------------------------------------------------------

  /**
   * Durchläuft die Knoten dieses Baums in Inorder-Reihenfolge und gibt deren Inhalt aus.
   *
   * @return Inhalte der Inorder-Traversierung, jeweils ein Knoteninhalt pro Zeile
   */
  public String gibInorderfolge() {

    return (this.wurzel == null)
            ? ""
            : this.wurzel.gibInorderfolge();
  }

  /**
   * Liefert die Preorder-Folge dieses Baums in eingerückter Form.
   *
   * @return Preorder-Folge in eingerückter Form mit einem Element pro Zeile
   */
  public String gibPreorderfolge() {

    return (this.wurzel == null)
            ? "(leer)"
            : this.wurzel.gibPreorderfolge();
  }

  /**
   * Gibt an, ob der übergebene Wert im Baum enthalten ist.
   *
   * @param wert Wert, für den geprüft wird, ob er im Suchbaum enthalten ist
   * @return {@code true} genau dann, wenn der Wert enthalten ist
   */
  public boolean istEnthalten(String wert) {

    /*
     * Wert ist enthalten, wenn Baum nicht leer ist und der durch die Wurzel aufgespannte Baum den
     * Wert enthält.
     */
    return (this.wurzel != null) && this.wurzel.istEnthalten(wert);
  }

  /**
   * Fügt dem Suchbaum einen neuen Knoten für den übergebenen Wert hinzu. Der Knoten wird so
   * hinzugefügt, dass der Baum ein Suchbaum bleibt.
   *
   * @param wert Wert, der dem Baum hinzugefügt wird
   */
  public void fuegeHinzuRekursiv(String wert) {

    if (this.wurzel == null) {

      /*
       * Baum ist leer. Ersten Knoten erzeugen.
       */
      this.wurzel = new Baumknoten(wert);

    } else {

      /*
       * Baum ist nicht leer. Wurzel bleibt beim Einfügen unverändert.
       */
      this.wurzel.fuegeHinzu(wert);
    }
  }

  /**
   * Fügt dem Suchbaum einen neuen Knoten für den übergebenen Wert hinzu. Der Knoten wird so
   * hinzugefügt, dass der Baum ein Suchbaum bleibt.
   *
   * @param wert Wert, der dem Baum hinzugefügt wird
   */
  public void fuegeHinzuIterativ(String wert) {

    /*
     * Blatt für übergebenen Wert erzeugen.
     */
    Baumknoten knoten = new Baumknoten(wert);

    /*
     * Baum von der Wurzel zu dem Knoten durchlaufen, an den der neue Knoten als Kind angefügt
     * werden muss.
     */

    /*
     * Enthält stets den Knoten, mit dem verglichen wird, ob der Wert rechts oder links davon
     * eingefügt werden muss.
     */
    Baumknoten aktuellerKnoten = this.wurzel;

    /*
     * Vorgänger des aktuellen Knotens. Enthält schließlich den Knoten, an dem der Knoten für den
     * einzufügenden Wert eingefügt wird.
     */
    Baumknoten vorgaenger = null;

    /*
     * Gibt an, ob beim Abstieg im Baum nach rechts verzweigt wurde. true genau dann, wenn nach
     * rechts verzweigt wurde. Wird benötigt, um am Ende entscheiden zu können, ob der neue Knoten
     * linkes oder rechtes Kind des Vorgängerknotens wird.
     */
    boolean nachRechtsVerzweigt = false;

    /*
     * Solange im Baum absteigen, wie noch kein Blatt erreicht ist.
     */
    while (aktuellerKnoten != null) {

      /*
       * Zum linken oder rechten Kind verzweigen. Aktueller Knoten wird dann zum Vorgänger dieses
       * Kindes.
       */
      vorgaenger = aktuellerKnoten;

      if (wert.compareTo(aktuellerKnoten.gibInhalt()) <= 0) {

        /*
         * Der einzufügende Wert ist kleiner oder gleich dem Inhalt des aktuellen Knotens. Der neue
         * Knoten muss im linken Teilbaum eingefügt werden.
         */
        nachRechtsVerzweigt = false;
        aktuellerKnoten = aktuellerKnoten.gibLinkenTeilbaum();

      } else {

        /*
         * Der einzufügende Wert ist größer als der Inhalt des aktuellen Knotens. Der neue Knoten
         * muss im rechten Teilbaum eingefügt werden.
         */
        nachRechtsVerzweigt = true;
        aktuellerKnoten = aktuellerKnoten.gibRechtenTeilbaum();
      }
    }

    if (vorgaenger == null) {

      /*
       * Die obige Schleife wurde nicht durchlaufen. Der Baum ist leer.
       */
      this.wurzel = knoten;

    } else if (nachRechtsVerzweigt) {

      /*
       * Die letzte Verzweigung erfolgte nach rechts. Der neue Knoten wird rechtes Kind des
       * Vorgängerknotens.
       */
      vorgaenger.setzeRechtenTeilbaum(knoten);

    } else {

      /*
       * Der neue Knoten wird linkes Kind des Vorgängerknotens.
       */
      vorgaenger.setzeLinkenTeilbaum(knoten);
    }
  }

  /**
   * Entfernt aus dem Suchbaum den angegebenen Wert, sofern er im Baum existiert. Gibt es keinen
   * Knoten mit diesem Wert, bleibt der Baum unverändert.
   *
   * @param wert Wert, der aus dem Baum entfernt wird
   */
  public void entferne(String wert) {

    if (this.wurzel != null) {
      this.wurzel = this.wurzel.entferne(wert);
    }
  }
}

```

### Binärer Suchbaum Test
```java

/**
 * Diese Klasse veranschaulicht durch Testaufrufe die Funktionsweise der
 * Klassen BinaererSuchbaum und Baumknoten.
 */
public class BinaererSuchbaumTest {

  /**
   * Liefert Baum mit Zeichenfolgen als Knoteninhalten.
   *
   * @param bauminhalte Daten, die im Baum abgelegt werden
   * @return Suchbaum mit den übergebenen Inhalten
   */
  private static BinaererSuchbaum erzeugeBaum(String... bauminhalte) {

    BinaererSuchbaum baum = new BinaererSuchbaum();

    for (String s : bauminhalte) {
      baum.fuegeHinzuRekursiv(s);
    }

    return baum;
  }

  /**
   * Gibt die Preorder-Folge eines Beispielbaums aus.
   */
  private static void testePreorderDurchlauf() {

    BinaererSuchbaum baum = erzeugeBaum("Fisch", "Birne", "Auto", "Dach", "Pech", "Maus", "Vogel");
//    baum = erzeugeBaum("Auto", "Birne", "Dach", "Fisch", "Maus", "Pech", "Vogel");  // Wörter aufsteigend sortiert
//    baum = erzeugeBaum("Vogel", "Pech", "Maus", "Fisch", "Dach", "Birne", "Auto");  // Wörter absteigend sortiert
    System.out.println(baum.gibPreorderfolge());
  }

  /**
   * Gibt die Inorder-Folge eines Beispielbaums aus.
   */
  private static void testeInorderDurchlauf() {

    BinaererSuchbaum baum = erzeugeBaum("Fisch", "Birne", "Auto", "Dach", "Pech", "Maus", "Vogel");
    System.out.println(baum.gibInorderfolge());
  }

  /**
   * Testet Methode zum rekursiven Hinzufügen von Inhalten in den Baum.
   */
  private static void testeRekursivesHinzufuegen() {

    BinaererSuchbaum baum;

    baum = new BinaererSuchbaum();  // leerer Baum
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    /*
     * Inhalte sind vorsortiert. Baum degeneriert zur Liste.
     */
    baum = erzeugeBaum("Auto", "Birne", "Dach", "Fisch", "Maus", "Pech", "Vogel");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    /*
     * Inhalte sind umgekehrt vorsortiert. Baum degeneriert zur Liste.
     */
    baum = erzeugeBaum("Vogel", "Pech", "Maus", "Fisch", "Dach", "Birne", "Auto");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    /*
     * Reihenfolge führt zu ausgeglichenem Baum.
     */
    baum = erzeugeBaum("Fisch", "Birne", "Auto", "Dach", "Pech", "Maus", "Vogel");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();
  }

  /**
   * Testet Methode zum iterativen Hinzufügen von Inhalten in den Baum.
   */
  private static void testeIterativesHinzufuegen() {

    BinaererSuchbaum baum = new BinaererSuchbaum();

    baum.fuegeHinzuIterativ("Fisch");
    baum.fuegeHinzuIterativ("Birne");
    baum.fuegeHinzuIterativ("Auto");
    baum.fuegeHinzuIterativ("Dach");
    baum.fuegeHinzuIterativ("Pech");
    baum.fuegeHinzuIterativ("Vogel");
    baum.fuegeHinzuIterativ("Maus");

    System.out.println(baum.gibPreorderfolge());
    System.out.println();
    System.out.println(baum.gibInorderfolge());
  }

  /**
   * Testet Methoden zum Entfernen von Inhalten aus dem Baum.
   */
  private static void testeEntfernen() {

    BinaererSuchbaum baum;

    baum = new BinaererSuchbaum();
    baum.entferne("Maus");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    /*
     * Reihenfolge führt zu ausgeglichenem Baum.
     */
    baum = erzeugeBaum("Fisch, Birne, Auto, Dach, Pech, Maus, Vogel");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    baum.entferne("Fisch");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    baum.entferne("Auto");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    baum.entferne("Vogel");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();

    baum.entferne("Pech");
    System.out.println(baum.gibPreorderfolge());
    System.out.println();
  }

  /**
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    testeInorderDurchlauf();
    testePreorderDurchlauf();
    testeRekursivesHinzufuegen();
    testeEntfernen();
    testeIterativesHinzufuegen();
  }
}

```
