#Vorlesung 
#EPR 
#Medieninformatik 

---
[[Skript - Programmierung mit Methoden und Ausdrücke]]
![[Skript - Programmierung mit Methoden und Ausdrücke]]


# Summary
- Fibonacci-Funktion
- Klassen und Objekte
	- Algorithmus


# Beispiel-Codes
## Endrekursion
```java
/**
 * Der Zweck dieser Klasse ist es, Code-Beispiele für endrekursiv
 * definierte Methoden zu geben.
 */
public class Endrekursion {

  /**
   * Liefert die Quersumme von <code>zahl</code> plus dem Wert von <code>summe</code>. Übergibt man
   * für <code>summe</code> 0, erhält man die Quersumme von <code>zahl</code>.
   *
   * @param zahl  Zahl, deren Quersumme berechnet wird; es muss gelten: zahl &gt;= 0
   * @param summe Summe
   * @return Quersumme von <code>zahl</code> plus <code>summe</code>
   */
  private static int quersumme(int zahl, int summe) {

    System.out.println("Zur Ablaufkontrolle: " + zahl + " " + summe);

    return zahl == 0
            ? summe
            : quersumme(zahl / 10, summe + zahl % 10);
  }

  /**
   * Liefert die Quersumme von zahl.
   *
   * @param zahl Zahl, deren Quersumme berechnet wird; es muss gelten: zahl = 0
   * @return Quersumme von zahl.
   */
  public static int quersumme(int zahl) {

    return quersumme(zahl, 0);
  }

  /**
   * Prüft, ob n durch eine Zahl aus dem Intervall {<code>teiler</code>, ...,
   * <code>n</code>-1} teilbar ist. Übergibt man für <code>teiler</code> 2, prüft die Methode, ob
   * <code>n</code> eine Prinzahl ist.
   *
   * @param n      Zahl, deren Teilbarkeit geprüft wird
   * @param teiler untere Grenze für das Intervall der Zahlen, durch die geteilt wird
   * @return {@code true} genau dann, wenn <code>n</code> durch keine Zahl aus dem Intervall teilbar
   *         ist
   */
  public static boolean istPrimzahl(int n, int teiler) {

    return (teiler == n)
            || (n % teiler != 0) && istPrimzahl(n, teiler + 1);
  }

  /**
   * Liefert die Summe aller Zahlen von startwert bis zielwert zzgl. dem Wert von Summe. Übergibt
   * man für <code>summe</code> 0, erhält man die Summe aller Zahlen von startwert bis zielwert.
   *
   * @param startwert Wert, ab dem summiert wird
   * @param zielwert  Wert, bis zu dem summiert wird
   * @param summe     Summe
   * @return Summe aller Zahlen von startwert bis zielwert plus summe
   */
  public static int summe(int startwert, int zielwert, int summe) {

    return startwert > zielwert
            ? summe
            : summe(startwert, zielwert - 1, summe + zielwert);
  }

  /**
   * Liefert den größten gemeinsamen Teiler zweier positiver, ganzer Zahlen.
   *
   * @param n erste Zahl
   * @param m zweite Zahl
   * @return größter gemeinsamer Teiler beider Zahlen
   */
  public static int ggT(int n, int m) {

    /*
     * endrekursive Realisierung nach Euklid
     */
    return m == 0
            ? n
            : ggT(m, n % m);
  }

  /**
   * Berechnet das Produkt aus <code>f</code> und der Fakultät von <code>n</code>. Als Spezialfall
   * berechnet die Methode die Fakultät von <code>n</code>, wenn für <code>f</code> 1 übergeben
   * wird.
   *
   * @param n Zahl, deren Fakultät mit <code>f</code> multipliziert wird
   * @param f Zahl, die mit der Fakultät von <code>n</code> multipliziert wird
   * @return Produkt aus <code>f</code> und der Fakultät von <code>n</code>
   */
  private static long fakultaet(int n, long f) {

    return n == 0
            ? f
            : fakultaet(n - 1, f * n);
  }

  /**
   * Berechnet die Fakultät von <code>n</code>.
   *
   * @param n Zahl, deren Fakultät berechnet wird
   * @return Fakultät von <code>n</code>
   */
  public static long fakultaet(int n) {

    return fakultaet(n, 1);
  }

  /**
   * Führt die Methoden dieser Klasse mit beispielhaften Parametern aus und gibt die Ergebnisse auf
   * dem Bildschirm aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    System.out.println(quersumme(2031, 0));

    System.out.println(istPrimzahl(41, 2));

    System.out.println(summe(4, 8, 0));

    System.out.println(ggT(24, 18));

    System.out.println(fakultaet(0));
    System.out.println(fakultaet(1));
    System.out.println(fakultaet(4));
  }
}
```


## Fibbonaci
```java
/**
 * Der Zweck dieser Klasse ist es, Code-Beispiele für baumrekursiv definierte Methoden zu geben.
 */
public class Baumrekursion {

  /**
   * Liefert das n-te Element der Fibonacci-Folge.
   *
   * @param n Index der Fibonacci-Folge, dessen Wert geliefert wird
   * @return Element der Fibonacci-Folge mit dem angegebenen Index
   */
  public static int fib(int n) {

    return (n <= 1)
            ? n
            : fib(n - 2) + fib(n - 1);

//        System.out.println("n = " + n);
//        int fibonacciWert = (n <= 1)
//                            ? n
//                            : fib(n - 2) + fib(n - 1);
//
//        System.out.println("fib(n) = " + fibonacciWert);
//        return fibonacciWert;
  }

  /**
   * Liefert Anweisung, um im Spiel „Türme von Hanoi“ eine Anzahl Scheiben von einem Platz zu einem
   * anderen zu bewegen.
   *
   * @param anzahl Anzahl Scheiben, die bewegt werden
   * @param start  Zahl zwischen 1 und 3, die den Platz angibt, auf dem anfangs die Scheiben liegen
   * @param ziel   Zahl zwischen 1 und 3, die den Platz angibt, auf dem am Ende die Scheiben liegen
   *               sollen. Es wird davon ausgegangen, dass beide Platznummern verschieden sind.
   * @return Anwensung zum Bewegen der Scheiben
   */
  public static String bewegeScheiben(int anzahl,
          int start, int ziel) {

    int zwischenplatz = 6 - start - ziel;
    return anzahl == 0
            ? ""
            : bewegeScheiben(anzahl - 1, start, zwischenplatz)
              + "Bewege Scheibe von " + start
              + " nach " + ziel + "\n"
              + bewegeScheiben(anzahl - 1, zwischenplatz, ziel);
  }

  /**
   * Liefert die Anzahl Ziffern einer Zahl.
   *
   * @param zahl
   * @return Ziffern der Zahl
   */
  public static int gibLaenge(long zahl) {

    return zahl < 10
            ? 1
            : gibLaenge(zahl / 10) + 1;
  }

  /**
   * Liefert die hinteren Ziffern einer Zahl als neue Zahl.
   *
   * @param zahl   Zahl, deren hintere Ziffern als neue Zahl geliefert werden
   * @param laenge Anzahl der hinteren Ziffern
   * @return hintere Ziffern der übergebenen Zahl als neue Zahl
   */
  public static long gibEnde(long zahl, int laenge) {

    return laenge == 1
            ? zahl % 10
            : 10 * gibEnde(zahl / 10, laenge - 1) + zahl % 10;
  }

  /**
   * Entfernt die hinteren Ziffern einer Zahl und liefert die resultierende Zahl.
   *
   * @param zahl
   * @param laenge Anzahl Ziffern, die „abgeschnitten“ werden
   * @return Zahl nach Abschneiden der hinteren Ziffern
   */
  public static long entferneEnde(long zahl, int laenge) {

    return laenge == 0
            ? zahl
            : entferneEnde(zahl / 10, laenge - 1);
  }

  /**
   * Liefert die Ziffern einer Zahl angeordnet in einem ausgeglichenen Baum.
   * <ul>
   * <li>Die mittlere Ziffer wird die Wurzel. Ist die Anzahl der Ziffern geradzahlig und gibt es
   * somit keine mittlere Ziffer, wird die Ziffer links der Mitte zur Wurzel.</li>
   * <li>Die Ziffern links davon werden nach gleicher Art zum linken Teilbaum, die Ziffern rechts
   * davon zum rechten Teilbaum.</li>
   * <li>Teilbäume werden durch Klammern eingeschlossen und der resultierende Baum als Zeichenkette
   * repräsentiert.</li>
   * </ul>
   *
   * @param zahl
   * @return Baumdarstellung der Ziffern der übergebenen Zahl
   */
  public static String gibAlsBaum(long zahl) {

    int laenge = gibLaenge(zahl);
    return zahl < 10
            ? "" + zahl
            : zahl < 100
                    ? zahl / 10 + "(" + zahl % 10 + ")"
                    : "(" + gibAlsBaum(entferneEnde(zahl, laenge / 2 + 1)) + ")"
                      + entferneEnde(zahl, laenge / 2) % 10
                      + "(" + gibAlsBaum(gibEnde(zahl, laenge / 2)) + ")";
  }

  /**
   * Führt die Methoden dieser Klasse mit beispielhaften Parametern aus und gibt die Ergebnisse auf
   * dem Bildschirm aus.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    System.out.println(fib(46));
    System.out.println(bewegeScheiben(4, 1, 3));

    System.out.println(gibAlsBaum(1));
    System.out.println(gibAlsBaum(12));
    System.out.println(gibAlsBaum(123));
    System.out.println(gibAlsBaum(1234567));
    System.out.println(gibAlsBaum(12345678));
    System.out.println(gibAlsBaum(123456789));
  }
}
```


## Zahlen sortieren
```java
/**
 * Diese Klasse enthält zwei Methoden, um die Ziffern einer Zahl des Typs long
 * zu sortieren.
 */
public class ZahlenSortieren {

  /**
   * Fügt eine Ziffer in eine Zahl ein, sodass die Ziffern der resultierenden Zahl sortiert sind. Es
   * wird davon ausgegangen, dass die Ziffern der übergebenen Zahl sortiert sind.
   *
   * @param zahl   Zahl, in die die übergebene Ziffer einsortiert wird
   * @param ziffer Ziffer, die einsortiert wird
   * @return Zahl, nachdem die Ziffer in die übergebene Zahl einsortiert wurde
   */
  public static long sortiertEinfuegen(long zahl, int ziffer) {

    return zahl == 0
            ? ziffer
            : zahl % 10 <= ziffer
                    ? 10 * zahl + ziffer
                    : sortiertEinfuegen(zahl / 10, ziffer) * 10 + zahl % 10;
  }

  /**
   * Sortiert eine Zahl ziffernweise.
   *
   * @param zahl Zahl, deren Ziffern sortiert werden
   * @return Zahl, die aus den Ziffern der übergebenen Zahl besteht, wobei diese Ziffern sortiert
   *         angeordnet sind
   */
  public static long insertionSort(long zahl) {

    /*
     * Algorithmus: Es werden, sofern die Zahl nicht einstellig ist, alle Ziffern der Zahl ohne die
     * letzte sortiert (Rekursion). In diese Ziffernfolge wird die letzte Ziffer sortiert eingefügt.
     */
    return zahl < 10
            ? zahl
            : sortiertEinfuegen(insertionSort(zahl / 10), (int) (zahl % 10));
  }

  /**
   * Berechnet für die übergebene Zahl eine Potenz von 10, sodass durch {@code zahl/p} und
   * {@code zahl%p} die Zahl in zwei Hälften geteilt werden kann, wobei {@code p} die berechnete
   * 10er-Potenz ist.
   *
   * @param zahl Zahl, für die die 10er-Potenz berechnet wird
   * @return 10er-Potenz, mit der die Zahl geteilt werden kann
   */
  public static long berechneTeiler(long zahl) {

    return zahl < 100
            ? 10
            : 10 * berechneTeiler(zahl / 100);
  }

  /**
   * Mischt zwei Zahlen, deren Ziffern sortiert sind, zu einer Zahl zusammen.Die Ziffern der
   * resultierenden Zahl sind sortiert.
   *
   * @param zahl1 Zahl, die mit zweiter Zahl zusammengemischt wird
   * @param zahl2 Zahl, die mit erster Zahl zusammengemischt wird
   * @return Zahl, die sich aus dem Zusammenmischen der beiden übergebenen Zahlen ergibt
   */
  public static long mische(long zahl1, long zahl2) {

    /*
     * Diese Implementierung ergänzen Sie bitte im Rahmen der entsprechenden praktischen Aufgabe.
     */
    return 0;
  }

  /**
   * Sortiert eine Zahl ziffernweise.
   *
   * @param zahl Zahl, deren Ziffern sortiert werden
   * @return Zahl, die aus den Ziffern der übergebenen Zahl besteht, wobei diese Ziffern sortiert
   *         angeordnet sind
   */
  public static long mergeSort(long zahl) {

    /*
     * Algorithmus: Es wird, sofern die Zahl nicht einstellig ist, die Ziffernfolge in zwei
     * Teilfolgen geteilt. Diese Teilfolgen werden sortiert (Rekursion). Die so sortierten
     * Teilfolgen werden zu einer Gesamtfolge verschmolzen (deshalb auch der Name merge). Das
     * Ergebnis ist die sortierte Ziffernfolge der ursprünglichen Zahl.
     */
    long teiler = berechneTeiler(zahl);
    return zahl < 10
            ? zahl
            : mische(mergeSort(zahl / teiler), mergeSort(zahl % teiler));
  }

  /**
   * Testet die Methoden dieser Klasse.
   *
   * @param args wird nicht verwendet
   */
  public static void main(String[] args) {

    System.out.println(sortiertEinfuegen(0, 5));
    System.out.println(sortiertEinfuegen(3, 5));
    System.out.println(sortiertEinfuegen(7, 5));
    System.out.println(sortiertEinfuegen(2468, 5));
    System.out.println(sortiertEinfuegen(1234, 5));

    System.out.println(insertionSort(993775135664421L));

    System.out.println(mergeSort(993775135664421L));
  }

}
```
